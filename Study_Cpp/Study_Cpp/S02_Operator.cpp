#define HUNGRY	1
#define THIRSTY	2
#define TIRED	4
#define HEAT	8
#define COLD	16

int S02_Operator() 
{
	/**
	*	▒ 연산자 ▒
	* 
	*	대입 연산자
	*	① =
	*	※ 컴퓨터는 연산의 결과를 레지스터의 누산기(AC)에 저장하기 때문에 메모리에 실제적으로 반영하기 위해서는 대입 연산자를 사용해줘야 한다.
	* 
	*	산술 연산자
	*	① +, -, *, /, %(modular)
	* 
	*	산술 대입 연산자
	*	① +=, -=
	* 
	*	증감 연산자
	*	① ++(전위), --(전위)	: 모든 연산자보다 우선순위가 높다. (※가능하면 전위 연산자를 쓰는 습관을 들이자.)
	*	② (후위)++, (후위)--	: 모든 연산자보다 연산자 우선순위가 낮다. (대입연산자보다 낮기 때문에 대입 연산자 처리 후 후위 연산자가 발생한다.)
	*	※ 증감 연산자는 일반적으로 산술적으로 상수를 증감시킨다는 것이 아니라 개념에 대한 증가와 감소를 나타낸다.
	* 
	*	비교 연산자
	*	① ==, !=	: 같거나 다르면 true
	*	② <, >, <=, >=	: 크기를 비교해서 맞으면 true
	* 
	* 
	*	논리 연산자
	*	① !(논리 부정), &&(논리 곱), ||(논리 합)
	* 
	*	※ 참(true), 거짓(false)
	*		참(true)		: 0이 아닌 모든 상수. (기본 1)
	*		거짓(false)	: 0
	* 
	*	삼항 연산자
	*	① (조건문):(true일)?(false)	: 조건문이 true 일 때 true 부분을, false 일 때 false 부분을 실행한다.
	* 
	* 
	*	비트 연산자
	*	① <<, >> (shift)
	*	② <<=, >>= (비트 대입 연산자)
	*	③ ~(비트 반전), &(비트 곱), |(비트 합), ^(XOR, 배타적 논리합)
	*		ⅰ) ^(XOR) : 2개의 입력이 서로 같으면 0, 다르면 1을 출력한다.
	*/
	int data = 10 + 20;
	data + 30; // 누산기(AC)에 저장되고 메모리에 쓰기 동작을 하기 전 상태

	// data = 10. % 3.;
	// data = 10 % 3.;	// 실수에는 나머지에 대한 개념이 모호하기 때문에 modular(%) 연산이 불가능하다.

	double data2 = 0.25;
	data2++;

	int a = 10;
	a = data++;	// a = 30, data = 31 (대입 이후 후위 증감 연산자가 발생했다.)
	
	unsigned char byte = 1;

	byte <<= 3;	// 2^n
	byte >>= 1;	// 2^-n

	/**
	*	▤ 비트 연산자를 사용한 상태이상 표현 ▤
	*	비트 연산자
	*	① <<, >> (shift)
	*	② <<=, >>= (비트 대입 연산자)
	*	③ ~(비트 반전), &(비트 곱), |(비트 합), ^(XOR, 배타적 논리합)
	*		ⅰ) & (AND)	: 두 개의 비트 모두 true면 true를 리턴한다.
	*					  두 비트 값을 곱해서 나온 결과와 같다고 해서 비트 곱이라고도 한다.
	*		ⅱ) | (OR)	: 두 개의 비트 중 하나라도 true면 true를 리턴한다.
	*					  두 개의 비트를 더해서 1 이상이면 1로 출력하기 때문에 비트 합이라고도 한다.
	*		ⅱ) ^ (XOR)	: 두 개의 비트가 서로 달라야 true를 리턴한다.
	*					  두 개의 비트가 서로 달라야 true를 리턴하기 때문에 베타적 비트 합이라고 한다. (쉽게 생각하면 승수를 버린 결과라고 볼 수 있다)
	*/
	unsigned int iStatus = 0;	// 아무런 상태이상이 없는 상태
	iStatus |= HUNGRY;	// iStatus의 결과에 해당 비트의 | (비트합)을 사용하면 해당 비트만 상태이상을 부여할 수 있다.
	iStatus |= COLD;	// iStatus의 결과에 서로 다른 상태를 비트합 했기 때문에 두 개의 상태이상이 부여 된 상황이다.

	if (iStatus & HUNGRY)
	{
		// 배고픈 상태라면 들어온다.
	}

	// ※ 상태이상 해제 (특정 자리의 상태이상 해제)
	iStatus &= ~COLD;	// COLD 상태를 해제하기 위해 비트 반전을 하면 해당 상태 자리가 false가 되기 때문에
						// 비트곱을 수행하면 원래 상태가 true인 상태는 true로, false면 false로 놔두고
						// 해당 상태이상 자리만 false이기 때문에 무조건 false로 리턴하게 된다.

	return 0;
}